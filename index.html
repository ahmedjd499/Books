<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="description" content="Offline PDF Book Reader - Read and track your books">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" id="manifestLink" href="#">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%234CAF50' width='100' height='100'/%3E%3Ctext y='75' font-size='75' text-anchor='middle' x='50'%3Eüìö%3C/text%3E%3C/svg%3E">
    <title>Book Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 16px;
            min-height: 100vh;
        }

        header {
            background: #252525;
            padding: 20px;
            margin: -16px -16px 20px -16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
        }

        .upload-section {
            background: #252525;
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            border-color: #666;
            background: #2a2a2a;
        }

        .upload-section.dragover {
            border-color: #4CAF50;
            background: #2a3a2a;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            display: inline-block;
            margin: 4px;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #555;
        }

        .btn-secondary:hover {
            background: #666;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .book-list {
            margin-top: 20px;
        }

        .book-item {
            background: #252525;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            gap: 12px;
        }

        .book-cover {
            width: 80px;
            height: 100px;
            background: #333;
            border-radius: 4px;
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 32px;
        }

        .book-cover canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-info {
            flex: 1;
            min-width: 0;
        }

        .book-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            word-break: break-word;
        }

        .book-progress {
            font-size: 14px;
            color: #888;
            margin-bottom: 12px;
        }

        .progress-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 8px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }

        .book-actions {
            display: flex;
            gap: 8px;
        }

        .book-actions .btn {
            flex: 1;
            margin: 0;
        }

        #readerView {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            z-index: 1000;
        }

        #readerView.active {
            display: flex;
            flex-direction: column;
        }

        .reader-header {
            background: #252525;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .reader-header.hidden {
            transform: translateY(-100%);
        }

        .reader-title {
            flex: 1;
            font-size: 16px;
            font-weight: bold;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .reader-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0;
        }

        .pdf-page {
            max-width: 100%;
            display: block;
            margin-bottom: 0;
            box-shadow: none;
        }

        .reader-controls {
            background: #252525;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .reader-controls.hidden {
            transform: translateY(100%);
        }

        .page-info {
            flex: 1;
            text-align: center;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        @media (max-width: 480px) {
            .btn {
                padding: 10px 16px;
                font-size: 14px;
            }
            
            h1 {
                font-size: 20px;
            }
        }

        .install-prompt {
            background: #2a2a2a;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            display: none;
        }

        .install-prompt.show {
            display: block;
        }

        .install-prompt p {
            margin-bottom: 12px;
        }

        .continue-reading {
            background: linear-gradient(135deg, #2a4a2a 0%, #1a3a1a 100%);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .continue-reading.show {
            display: block;
        }

        .continue-reading-label {
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .continue-reading-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .continue-reading-progress {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="container" id="homeView">
        <header>
            <h1>üìö Book Reader</h1>
            <p class="subtitle">Your offline PDF library</p>
        </header>

        <div class="install-prompt" id="installPrompt">
            <p><strong>Install this app!</strong> Add to your home screen for a better experience.</p>
            <button class="btn" id="installButton">Install</button>
            <button class="btn btn-secondary" id="dismissInstall">Dismiss</button>
        </div>

        <div class="continue-reading" id="continueReading">
            <div class="continue-reading-label">Continue Reading</div>
            <div class="continue-reading-title" id="continueReadingTitle"></div>
            <div class="continue-reading-progress" id="continueReadingProgress"></div>
            <button class="btn" id="continueReadingBtn">Continue Reading</button>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üì§</div>
            <h3>Upload a PDF Book</h3>
            <p style="margin: 12px 0; color: #888;">Click or drag and drop</p>
            <button class="btn">Choose File</button>
            <input type="file" id="fileInput" accept=".pdf,application/pdf" multiple>
        </div>

        <div class="book-list" id="bookList"></div>
    </div>

    <div id="readerView">
        <div class="reader-header">
            <button class="btn btn-secondary" id="closeReader">‚Üê</button>
            <div class="reader-title" id="readerTitle"></div>
        </div>
        <div class="reader-content" id="readerContent">
            <!-- PDF pages will be rendered here as canvases -->
        </div>
        <div class="reader-controls">
            <button class="btn btn-secondary" id="prevPage">Previous</button>
            <div class="page-info" id="pageInfo">Page 1 of 1</div>
            <button class="btn btn-secondary" id="nextPage">Next</button>
        </div>
    </div>

    <script type="module">
        // Import PDF.js as ES module
        import * as pdfjsLib from './build/pdfjs/pdf.min.mjs';
        
        // Initialize PDF.js with error handling
        if (pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'build/pdfjs/pdf.worker.min.mjs';
            // Make pdfjsLib available globally for compatibility
            window.pdfjsLib = pdfjsLib;
        } else {
            console.warn('PDF.js not loaded - may be blocked by ad blocker or network');
        }

        // Database management
        const DB_NAME = 'BookReaderDB';
        const DB_VERSION = 2;
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('books')) {
                        const booksStore = db.createObjectStore('books', { keyPath: 'id', autoIncrement: true });
                        booksStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    if (!db.objectStoreNames.contains('progress')) {
                        const progressStore = db.createObjectStore('progress', { keyPath: 'bookId' });
                    }

                    if (!db.objectStoreNames.contains('thumbnails')) {
                        const thumbnailsStore = db.createObjectStore('thumbnails', { keyPath: 'bookId' });
                    }
                };
            });
        }

        async function saveBook(name, data) {
            const transaction = db.transaction(['books'], 'readwrite');
            const store = transaction.objectStore('books');
            return new Promise((resolve, reject) => {
                const request = store.add({ name, data, addedAt: Date.now() });
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getAllBooks() {
            const transaction = db.transaction(['books'], 'readonly');
            const store = transaction.objectStore('books');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getBook(id) {
            const transaction = db.transaction(['books'], 'readonly');
            const store = transaction.objectStore('books');
            return new Promise((resolve, reject) => {
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteBook(id) {
            const transaction = db.transaction(['books', 'progress'], 'readwrite');
            const booksStore = transaction.objectStore('books');
            const progressStore = transaction.objectStore('progress');
            
            return Promise.all([
                new Promise((resolve, reject) => {
                    const request = booksStore.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                }),
                new Promise((resolve, reject) => {
                    const request = progressStore.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                })
            ]);
        }

        async function saveProgress(bookId, currentPage, totalPages) {
            const transaction = db.transaction(['progress'], 'readwrite');
            const store = transaction.objectStore('progress');
            return new Promise((resolve, reject) => {
                const request = store.put({ bookId, currentPage, totalPages, lastRead: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getProgress(bookId) {
            const transaction = db.transaction(['progress'], 'readonly');
            const store = transaction.objectStore('progress');
            return new Promise((resolve, reject) => {
                const request = store.get(bookId);
                request.onsuccess = () => resolve(request.result || { currentPage: 1 });
                request.onerror = () => reject(request.error);
            });
        }

        async function saveThumbnail(bookId, dataUrl) {
            const transaction = db.transaction(['thumbnails'], 'readwrite');
            const store = transaction.objectStore('thumbnails');
            return new Promise((resolve, reject) => {
                const request = store.put({ bookId, dataUrl });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getThumbnail(bookId) {
            const transaction = db.transaction(['thumbnails'], 'readonly');
            const store = transaction.objectStore('thumbnails');
            return new Promise((resolve, reject) => {
                const request = store.get(bookId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getLastReadBook() {
            const transaction = db.transaction(['progress'], 'readonly');
            const store = transaction.objectStore('progress');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => {
                    const allProgress = request.result;
                    if (allProgress.length === 0) {
                        resolve(null);
                        return;
                    }
                    // Find the most recently read book
                    const lastRead = allProgress.reduce((latest, current) => {
                        return (current.lastRead > latest.lastRead) ? current : latest;
                    });
                    resolve(lastRead);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function generateThumbnail(bookData, bookId) {
            try {
                if (!pdfjsLib) return null;
                
                const loadingTask = pdfjsLib.getDocument({ data: bookData });
                const pdf = await loadingTask.promise;
                const page = await pdf.getPage(1);
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // Small scale for thumbnail
                const viewport = page.getViewport({ scale: 0.5 });
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
                await saveThumbnail(bookId, dataUrl);
                
                pdf.destroy();
                return dataUrl;
            } catch (error) {
                console.error('Error generating thumbnail:', error);
                return null;
            }
        }

        // UI Management
        let currentBook = null;
        let currentPdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let pageCanvases = [];
        let scrollListenerAdded = false;
        let scrollTimeout = null;
        let controlsVisible = true;
        let hideControlsTimeout = null;

        // Throttle function to limit scroll event firing
        function throttle(func, delay) {
            return function(...args) {
                if (scrollTimeout) return;
                scrollTimeout = setTimeout(() => {
                    func.apply(this, args);
                    scrollTimeout = null;
                }, delay);
            };
        }

        async function displayBooks() {
            const bookList = document.getElementById('bookList');
            const books = await getAllBooks();
            
            // Handle continue reading section
            const lastReadProgress = await getLastReadBook();
            if (lastReadProgress && lastReadProgress.currentPage > 1) {
                const lastReadBook = await getBook(lastReadProgress.bookId);
                if (lastReadBook) {
                    document.getElementById('continueReadingTitle').textContent = lastReadBook.name;
                    document.getElementById('continueReadingProgress').textContent = 
                        `Page ${lastReadProgress.currentPage} of ${lastReadProgress.totalPages}`;
                    document.getElementById('continueReading').classList.add('show');
                    
                    // Set up click handler
                    const continueBtn = document.getElementById('continueReadingBtn');
                    continueBtn.onclick = () => openBook(lastReadBook.id);
                }
            } else {
                document.getElementById('continueReading').classList.remove('show');
            }
            
            if (books.length === 0) {
                bookList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <p>No books yet. Upload a PDF to get started!</p>
                    </div>
                `;
                return;
            }
            
            bookList.innerHTML = '';
            
            for (const book of books) {
                const progress = await getProgress(book.id);
                const percentage = progress.totalPages ? 
                    Math.round((progress.currentPage / progress.totalPages) * 100) : 0;
                
                const bookItem = document.createElement('div');
                bookItem.className = 'book-item';
                
                // Book cover
                const bookCover = document.createElement('div');
                bookCover.className = 'book-cover';
                bookCover.textContent = 'üìÑ';
                
                // Try to load thumbnail
                const thumbnail = await getThumbnail(book.id);
                if (thumbnail && thumbnail.dataUrl) {
                    const img = document.createElement('canvas');
                    const ctx = img.getContext('2d');
                    const image = new Image();
                    image.onload = () => {
                        img.width = 80;
                        img.height = 100;
                        ctx.drawImage(image, 0, 0, img.width, img.height);
                    };
                    image.src = thumbnail.dataUrl;
                    bookCover.innerHTML = '';
                    bookCover.appendChild(img);
                } else {
                    // Generate thumbnail in background
                    generateThumbnail(book.data, book.id).then(dataUrl => {
                        if (dataUrl) {
                            const img = document.createElement('canvas');
                            const ctx = img.getContext('2d');
                            const image = new Image();
                            image.onload = () => {
                                img.width = 80;
                                img.height = 100;
                                ctx.drawImage(image, 0, 0, img.width, img.height);
                            };
                            image.src = dataUrl;
                            bookCover.innerHTML = '';
                            bookCover.appendChild(img);
                        }
                    });
                }
                
                // Book info container
                const bookInfo = document.createElement('div');
                bookInfo.className = 'book-info';
                
                const bookTitle = document.createElement('div');
                bookTitle.className = 'book-title';
                bookTitle.textContent = book.name;
                
                const bookProgress = document.createElement('div');
                bookProgress.className = 'book-progress';
                bookProgress.textContent = progress.totalPages ? 
                    `Page ${progress.currentPage} of ${progress.totalPages}` : 
                    'Not started';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                const progressFill = document.createElement('div');
                progressFill.className = 'progress-fill';
                progressFill.style.width = `${percentage}%`;
                progressBar.appendChild(progressFill);
                
                const bookActions = document.createElement('div');
                bookActions.className = 'book-actions';
                
                const readBtn = document.createElement('button');
                readBtn.className = 'btn';
                readBtn.textContent = progress.currentPage > 1 ? 'Continue Reading' : 'Start Reading';
                readBtn.addEventListener('click', () => openBook(book.id));
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-danger';
                deleteBtn.textContent = 'Delete';
                deleteBtn.addEventListener('click', () => confirmDelete(book.id, book.name));
                
                bookActions.appendChild(readBtn);
                bookActions.appendChild(deleteBtn);
                
                bookInfo.appendChild(bookTitle);
                bookInfo.appendChild(bookProgress);
                bookInfo.appendChild(progressBar);
                bookInfo.appendChild(bookActions);
                
                bookItem.appendChild(bookCover);
                bookItem.appendChild(bookInfo);
                
                bookList.appendChild(bookItem);
            }
        }

        async function handleFileUpload(files) {
            for (const file of files) {
                if (file.type === 'application/pdf') {
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        await saveBook(file.name, arrayBuffer);
                    } catch (error) {
                        console.error('Error uploading book:', error);
                        alert(`Failed to upload ${file.name}`);
                    }
                }
            }
            displayBooks();
        }

        async function openBook(bookId) {
            const book = await getBook(bookId);
            if (!book) return;
            
            // Check if PDF.js is available
            if (typeof pdfjsLib === 'undefined') {
                alert('PDF viewer is not available. Please ensure you have an internet connection and refresh the page.');
                return;
            }
            
            currentBook = book;
            const progress = await getProgress(bookId);
            
            document.getElementById('homeView').style.display = 'none';
            document.getElementById('readerView').classList.add('active');
            document.getElementById('readerTitle').textContent = book.name;
            
            // Initialize controls as visible
            controlsVisible = true;
            showControls();
            
            try {
                const loadingTask = pdfjsLib.getDocument({ data: book.data });
                currentPdfDoc = await loadingTask.promise;
                totalPages = currentPdfDoc.numPages;
                currentPage = progress.currentPage || 1;
                
                await renderAllPages();
                updatePageInfo();
                scrollToPage(currentPage);
                await saveProgress(bookId, currentPage, totalPages);
                
                // Hide controls after a short delay
                startHideControlsTimer();
            } catch (error) {
                console.error('Error opening PDF:', error);
                alert('Failed to open PDF. The file may be corrupted.');
                closeReader();
            }
        }

        async function renderAllPages() {
            const readerContent = document.getElementById('readerContent');
            readerContent.innerHTML = '';
            pageCanvases = [];
            
            const containerWidth = readerContent.clientWidth;
            
            // Note: For very large PDFs (100+ pages), consider implementing 
            // progressive loading where pages are rendered as they scroll into view
            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                const page = await currentPdfDoc.getPage(pageNum);
                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-page';
                canvas.dataset.pageNumber = pageNum;
                const context = canvas.getContext('2d');
                
                const viewport = page.getViewport({ scale: 1 });
                const scale = Math.min(
                    containerWidth / viewport.width,
                    1.5 // Max scale to keep quality good
                );
                const scaledViewport = page.getViewport({ scale });
                
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;
                
                await page.render({
                    canvasContext: context,
                    viewport: scaledViewport
                }).promise;
                
                readerContent.appendChild(canvas);
                pageCanvases.push(canvas);
            }
            
            // Set up scroll listener to track current page
            setupScrollTracking();
        }

        function setupScrollTracking() {
            if (scrollListenerAdded) return;
            
            const readerContent = document.getElementById('readerContent');
            
            // Throttle scroll events to improve performance
            const throttledScrollHandler = throttle(updateCurrentPageFromScroll, 150);
            readerContent.addEventListener('scroll', throttledScrollHandler);
            
            scrollListenerAdded = true;
        }

        function showControls() {
            const header = document.querySelector('.reader-header');
            const controls = document.querySelector('.reader-controls');
            
            if (header) header.classList.remove('hidden');
            if (controls) controls.classList.remove('hidden');
            
            controlsVisible = true;
        }

        function hideControls() {
            const header = document.querySelector('.reader-header');
            const controls = document.querySelector('.reader-controls');
            
            if (header) header.classList.add('hidden');
            if (controls) controls.classList.add('hidden');
            
            controlsVisible = false;
        }

        function toggleControls() {
            if (controlsVisible) {
                hideControls();
            } else {
                showControls();
                startHideControlsTimer();
            }
        }

        function startHideControlsTimer() {
            // Clear any existing timer
            if (hideControlsTimeout) {
                clearTimeout(hideControlsTimeout);
            }
            
            // Hide controls after 3 seconds of inactivity
            hideControlsTimeout = setTimeout(() => {
                hideControls();
            }, 3000);
        }

        function cancelHideControlsTimer() {
            if (hideControlsTimeout) {
                clearTimeout(hideControlsTimeout);
                hideControlsTimeout = null;
            }
        }

        function updateCurrentPageFromScroll() {
            const readerContent = document.getElementById('readerContent');
            const scrollTop = readerContent.scrollTop;
            const viewportHeight = readerContent.clientHeight;
            const viewportCenter = scrollTop + viewportHeight / 2;
            
            // Find which page is currently in view
            for (let i = 0; i < pageCanvases.length; i++) {
                const canvas = pageCanvases[i];
                const canvasTop = canvas.offsetTop;
                const canvasBottom = canvasTop + canvas.height;
                
                if (viewportCenter >= canvasTop && viewportCenter < canvasBottom) {
                    const newPage = i + 1;
                    if (newPage !== currentPage) {
                        currentPage = newPage;
                        updatePageInfo();
                        
                        // Save progress
                        if (currentBook) {
                            saveProgress(currentBook.id, currentPage, totalPages);
                        }
                    }
                    break;
                }
            }
        }

        function scrollToPage(pageNum) {
            if (pageNum < 1 || pageNum > totalPages) return;
            
            const canvas = pageCanvases[pageNum - 1];
            if (canvas) {
                const readerContent = document.getElementById('readerContent');
                const scrollTop = canvas.offsetTop - 20; // 20px padding
                readerContent.scrollTo({ top: scrollTop, behavior: 'smooth' });
            }
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage} of ${totalPages}`;
            
            document.getElementById('prevPage').disabled = currentPage <= 1;
            document.getElementById('nextPage').disabled = currentPage >= totalPages;
        }

        async function goToPage(pageNum) {
            if (pageNum < 1 || pageNum > totalPages) return;
            
            scrollToPage(pageNum);
        }

        function closeReader() {
            document.getElementById('readerView').classList.remove('active');
            document.getElementById('homeView').style.display = 'block';
            
            // Clear rendered pages
            const readerContent = document.getElementById('readerContent');
            readerContent.innerHTML = '';
            pageCanvases = [];
            scrollListenerAdded = false;
            
            // Clear any pending scroll timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }
            
            // Clear hide controls timer
            cancelHideControlsTimer();
            
            // Reset controls visibility
            showControls();
            
            if (currentPdfDoc) {
                currentPdfDoc.destroy();
                currentPdfDoc = null;
            }
            currentBook = null;
        }

        async function confirmDelete(bookId, bookName) {
            if (confirm(`Are you sure you want to delete "${bookName}"?`)) {
                await deleteBook(bookId);
                displayBooks();
            }
        }

        // Event Listeners
        document.getElementById('uploadSection').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileUpload(e.target.files);
                e.target.value = '';
            }
        });

        // Drag and drop
        const uploadSection = document.getElementById('uploadSection');
        
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
            if (files.length > 0) {
                handleFileUpload(files);
            }
        });

        document.getElementById('closeReader').addEventListener('click', closeReader);
        document.getElementById('prevPage').addEventListener('click', () => goToPage(currentPage - 1));
        document.getElementById('nextPage').addEventListener('click', () => goToPage(currentPage + 1));

        // Add click/tap listener to reader content to toggle controls
        document.getElementById('readerContent').addEventListener('click', (e) => {
            toggleControls();
        });

        // When user interacts with controls, restart the hide timer
        document.querySelector('.reader-header')?.addEventListener('click', (e) => {
            e.stopPropagation();
            startHideControlsTimer();
        });

        document.querySelector('.reader-controls')?.addEventListener('click', (e) => {
            e.stopPropagation();
            startHideControlsTimer();
        });

        // Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Create service worker inline
                const swCode = `
                    const CACHE_NAME = 'book-reader-v1';
                    const APP_PATH = location.pathname.substring(0, location.pathname.lastIndexOf('/') + 1);
                    const urlsToCache = [APP_PATH];

                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => cache.addAll(urlsToCache))
                        );
                        self.skipWaiting();
                    });

                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then((response) => {
                                    if (response) {
                                        return response;
                                    }
                                    return fetch(event.request).then((response) => {
                                        if (!response || response.status !== 200 || response.type !== 'basic') {
                                            return response;
                                        }
                                        const responseToCache = response.clone();
                                        caches.open(CACHE_NAME).then((cache) => {
                                            cache.put(event.request, responseToCache);
                                        });
                                        return response;
                                    }).catch(() => {
                                        return caches.match(APP_PATH + 'index.html');
                                    });
                                })
                        );
                    });

                    self.addEventListener('activate', (event) => {
                        event.waitUntil(
                            caches.keys().then((cacheNames) => {
                                return Promise.all(
                                    cacheNames.map((cacheName) => {
                                        if (cacheName !== CACHE_NAME) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                    });
                `;

                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(() => console.log('Service Worker registered'))
                    .catch((error) => console.error('Service Worker registration failed:', error));
            });
        }

        // PWA Install Prompt
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installPrompt').classList.add('show');
        });

        document.getElementById('installButton').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to install prompt: ${outcome}`);
                deferredPrompt = null;
                document.getElementById('installPrompt').classList.remove('show');
            }
        });

        document.getElementById('dismissInstall').addEventListener('click', () => {
            document.getElementById('installPrompt').classList.remove('show');
        });

        // Manifest
        const getBasePath = () => {
            const path = window.location.pathname;
            return path.substring(0, path.lastIndexOf('/') + 1) || './';
        };

        const manifest = {
            name: 'Book Reader',
            short_name: 'Books',
            description: 'Offline PDF Book Reader',
            start_url: './',
            scope: './',
            display: 'standalone',
            background_color: '#1a1a1a',
            theme_color: '#1a1a1a',
            orientation: 'portrait-primary',
            icons: [
                {
                    src: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect fill="%234CAF50" width="100" height="100"/%3E%3Ctext y="75" font-size="75" text-anchor="middle" x="50"%3Eüìö%3C/text%3E%3C/svg%3E',
                    sizes: '192x192',
                    type: 'image/svg+xml',
                    purpose: 'any maskable'
                },
                {
                    src: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect fill="%234CAF50" width="100" height="100"/%3E%3Ctext y="75" font-size="75" text-anchor="middle" x="50"%3Eüìö%3C/text%3E%3C/svg%3E',
                    sizes: '512x512',
                    type: 'image/svg+xml',
                    purpose: 'any maskable'
                }
            ]
        };

        const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.getElementById('manifestLink').setAttribute('href', manifestURL);

        // Initialize app
        window.addEventListener('DOMContentLoaded', () => {
            initDB().then(() => {
                displayBooks();
            }).catch((error) => {
                console.error('Failed to initialize database:', error);
                alert('Failed to initialize the app. Please try refreshing the page.');
            });
        });
    </script>
</body>
</html>
